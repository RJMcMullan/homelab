{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#current-network-setup","title":"Current Network setup","text":"<p>So my current setup is this. The internet comes in the my home using my local ISP ONT box which gives me full 1 Gb fiber, excellent! The nokia ISP router is put into bridged mode so that I can have the main opnsense router (in green) do all the routing for me. I have VLANS, DHCP and other services running on my opnsense which i would rather use than the bog standard Nokia router. I'll go through this setup later.</p> <p>The opnsense router LAN port is connected to an 8 port TP-Link switch, which has VLANS configured on it and this switch is connected to an 16 port TP-Link poe switch up stair in my office. To pass the VLAN information the ports on both switch have to be tagged with all the VLANS so that traffic can be routed to the correct VLANS. </p> <p></p>"},{"location":"#vlan-configuration-8-port-switch","title":"VLAN configuration (8 port switch)","text":"<p>TP-link TL-SG1016PE </p>"},{"location":"#vlan-configuration-16-port-switch","title":"VLAN configuration (16 port switch)","text":"<p>TP-link TL-SG108E </p>"},{"location":"cloudflared/traefik/cloudflared-ha-proxy-traefik/","title":"HAProxy + Traefik + Let's Encrypt Wildcard Certificates + 100% A+ ssl Rating","text":""},{"location":"cloudflared/traefik/cloudflared-ha-proxy-traefik/#configuration-guide","title":"Configuration Guide","text":"<p>This is the help anyone wanting to implement a reverse proxy into their homelab environment, for hosting personal websites and projects to the public.</p>"},{"location":"cloudflared/traefik/cloudflared-ha-proxy-traefik/#part-1-plugin-installation","title":"Part 1 - Plugin Installation","text":"<p>1. Update your OPNsense to the latest version and ensure you're using the OpenSSL firmware flavor, as LibreSSL doesn't support TLS 1.3. - Navigate to \"System --&gt; Firmware --&gt; Updates\" and install all updates.</p> <p>2. Install necessary plugins: - Go to \"System --&gt; Firmware --&gt; Plugins\" and install the following: <code>os-acme-client</code>, <code>os-ddclient</code>, <code>os-haproxy</code>.</p>"},{"location":"cloudflared/traefik/cloudflared-ha-proxy-traefik/#part-2-dynamic-dns-configuration-using-cloudflare","title":"Part 2 - Dynamic DNS Configuration using cloudflare","text":"<p>1. Create and verify an account on cloudflare.</p> <p>2. Create your subdomain: - Go to cloudflare &gt; websites &gt; domain name &gt; DNS &gt; records and create your domain (e.g. <code>homelab.devopsjourneys.wiki</code>).</p> <p></p> <p>3. Generate and save a token:    - Log in to your Cloudflare account and navigate to the dashboard.    - Click on the profile icon in the top right corner and select \"My Profile.\"    - In the left-hand menu, click on \"API Tokens,\" then select \"Create Token.\"    - Choose the \"Edit zone DNS\" template from the list of API token templates.    - In the \"Zone Resources\" section, select the desired domain from the right-most dropdown menu, then click \"Continue to summary.\"    - Verify that the API token has DNS    - permission for the selected domain and click \"Create Token.\"</p> <p>4. Setup the Dynamic DNS plugin in OPNSENSE and enter the following information:</p> <ul> <li>Enabled: true</li> <li>Description: Cloudflare (Or whatever you want)</li> <li>Service: Cloudflare</li> <li>Username: token (the word, not your API token)</li> <li>Password:  <li>Zone: your.domain (e.g. devopsjourneys.wiki)</li> <li>Hostname: full domain name (e.g. homelab.devopsjourneys.wiki)</li> <li>Check ip method: Interface</li> <li>Interface to monitor: WAN</li> <li>Force SSL: true    </li>"},{"location":"cloudflared/traefik/cloudflared-ha-proxy-traefik/#part-3-lets-encrypt-acme-client","title":"Part 3 - Let's Encrypt (ACME Client)","text":"<p>1. Configure ACME Client settings in OPNsense:</p> <p>- Navigate to \"Services --&gt; ACME Client --&gt; Settings\" and adjust settings as this image.</p> <p>2. Set update schedule for certificate renewal:</p> <p>In this section, we will set the time of day for certificate renewals. Certificates won't be renewed daily; the ACME client first checks if they are nearing expiration and only renews them if necessary. Schedule the renewal for a time when your services experience low traffic, as the ACME plugin will restart HAProxy to apply the new certificates, causing a brief downtime. Avoid scheduling renewals at exact hours (e.g., 3:00 AM) since Let's Encrypt servers might be overloaded, potentially causing the renewal process to fail   - Go to \"Services --&gt; ACME Client --&gt; Settings --&gt; Update Schedule\" and configure a time with low service load. 3. Create an ACME account:   - Go to \"Services --&gt; ACME Client --&gt; Accounts\" and create an account using the staging environment first. </p> <p>4. Set up automation:   - Create an automation to restart HAProxy after certificate renewal.  5. Add DNS challenge:   - Go to \"Services --&gt; ACME Client --&gt; Challenge Types\" and add the DNS challenge for deSEC.  6. Add your certificate:   - Configure the certificate in \"Services --&gt; ACME Client --&gt; Certificates\".   I prefer using Elliptic Curve Cryptography (ECC) (https://en.wikipedia.org/wiki/Elliptic-curve_cryptography). However, you can also use RSA keys. If you choose RSA, ensure the key length is as long as possible to achieve an A+ rating from SSLLabs.   - Forcefully issue a staging certificate for testing, then switch to the production environment and issue the certificate by selecting the highlighted part here: </p> <p>### Part 4 - System Preparation</p> <p>1. Adjust system settings:   - Go to \"System --&gt; Settings --&gt; Administration\" and change the Web GUI TCP port (anything other than 443), and disable the web GUI redirect rule.</p> <p>2. Optional: Configure Virtual IPs: Create a virtual IP in a subnet different from any of your other networks. Ideally, select an IP from the localhost subnet to avoid conflicts in your local network (https://en.wikipedia.org/wiki/Localhost). In this tutorial, we will use \"127.4.4.3/32\" as the IP address for both the \"HTTP_frontend\" and \"HTTPS_frontend\".   - Create a virtual IP in \"Interfaces --&gt; Virtual IPs --&gt; Settings\" if not using localhost.  3. Create a firewall alias:   - Go to \"Firewall --&gt; Aliases\" and create an alias for HAProxy ports (port 80 and 443).  4. Set up firewall rules:   - Allow inbound traffic on HAProxy ports via \"Firewall --&gt; Rules --&gt; WAN\". </p>"},{"location":"cloudflared/traefik/cloudflared-ha-proxy-traefik/#part-5-haproxy-configuration","title":"Part 5 - HAProxy Configuration","text":"<p>1. Configure HAProxy settings:   - Go to \"Services --&gt; HAProxy --&gt; Settings --&gt; Service\" and adjust as needed.  \u00a0 \u00a0- Update \"Global Parameters\" and \"Default Parameters\" in HAProxy settings.  </p> <p>2. Add real servers and backend pools:   - Here we add the \"Real Servers\" the internal IP in my case of my traefik instance running on docker, the description and port   - The wildcard certificate we created above is also added here *.devopsjourney.wiki    </p> <ul> <li>Set up backend pools for services in \"Virtual Services --&gt; Backend Pools\".</li> </ul> <p>  3. Create rules and conditions:   - Add a NoSSL_condition\", which is necessary in order to identify non-HTTPS traffic      - Create a HTTPtoHTTPS rule. This is so the client connection gets upgraded from HTTP to HTTPS and connects to the HTTPS_frontend   - Create map files for public subdomains.  Here, we will generate a new map file named \"PUBLIC_SUBDOMAINS_mapfile\" for the public subdomains we want to access externally from our network. HAProxy map files are used to store key-value pairs that can be referenced by HAProxy during its operation. These map files allow for efficient lookups and are typically used for tasks such as URL rewriting, header modification, or directing traffic based on specific criteria. Key features of HAProxy map files include: - Format: Each line in a map file represents a key-value pair, separated by spaces or tabs. The key is usually some form of input (like a URL or host) and the value is the corresponding output (like a backend server or a rewritten URL).</p> <p>Example:   subdomain1.example.com backend1   subdomain2.example.com backend2</p> <ul> <li>Usage: Map files are referenced in HAProxy configuration using directives such as use-server, acl, or http-request. This enables dynamic behavior based on the contents of the map file.</li> <li>Efficiency: Map files allow HAProxy to handle complex routing and transformation rules efficiently without hardcoding them into the configuration, enabling easier updates and maintenance.</li> <li> <p>Reloading: HAProxy can reload map files on the fly without requiring a full restart, which minimizes downtime and allows for dynamic updates to routing logic.</p> </li> <li> <p>Now create the Map file and PUBLIC_SUBDOMAINS_map-rule as follows    </p> </li> </ul> <p>4. Configure Public Services (frontends):   - Set up SNI, HTTP, and HTTPS frontends in \"Virtual Services --&gt; Public Services\".   Here, we will set up the frontends to listen on our interface IPs and the virtual IP we created earlier. First, we will create the \"SNI_frontend,\" which will determine whether the traffic should be SSL offloaded. You will need to place the rules for all services that you don't want to be SSL offloaded here. The default backend for this frontend will be the \"SSL_backend,\" which redirects all traffic to our virtual \"SSL_server,\" corresponding to our \"HTTPS_frontend.\"      - Now we will set up our \"HTTP_frontend.\" Ensure that the \"HTTPtoHTTPS_rule\" is included in this frontend! This frontend is essential for redirecting HTTP traffic to HTTPS, but it can also be used to serve non-SSL encrypted services on port 80.       - Now we will set up our \"HTTPS_frontend.\" This will be our primary frontend, performing SSL offloading using the Let's Encrypt certificate we created earlier. You should include the \"PUBLIC_SUBDOMAINS_rule\" and all other rules for services that need SSL offloading here. The \"Cipher List\" and \"Cipher Suites\" will ensure we achieve a 100% A+ rating at SSLLabs.</p>"},{"location":"cloudflared/traefik/cloudflared-ha-proxy-traefik/#part-6-internal-network-access","title":"Part 6 - Internal Network Access","text":"<p>1. Option A: Split DNS:    If you attempt to access your URL \"your_service.your_subdomain.dedyn.io\" from a device within your internal network, it should fail There are two ways to resolve this issue. I will cover both options, but note that Split DNS (Option A) is the recommended approach. NAT Reflection (Option B) is a less favorable solution because it causes you to lose the ability to track the originating source IP in HAProxy when using NAT.</p> <p>Option A - Split DNS (https://docs.opnsense.org/manual/unbound.html#overrides) Option B - NAT Reflection (https://docs.opnsense.org/manual/nat.html)   - Use Unbound DNS plugin for DNS overrides.   - Go to \"Services --&gt; Unbound DNS --&gt; Overrides\" and create host overrides for each of your services. This applies if you are using second-level subdomains like \"your_service.your_subdomain.dedyn.io\" for your services. If all your services run on your first-level subdomain \"your_subdomain.dedyn.io,\" you only need to override this one. The IP address can be any LAN (or VLAN) interface IP of your OPNsense. I am using the LAN IP that the \"SNI_frontend\" is also listening on, since we set it to \"0.0.0.0\".</p> <p>2. Option B: NAT Reflection:</p> <ul> <li>Edit port forwarding rules in \"Firewall --&gt; NAT --&gt; Port Forward\" to enable NAT reflection.</li> </ul>"},{"location":"cloudflared/traefik/cloudflared-ha-proxy-traefik/#part-7-local-access-only-subdomains","title":"Part 7 - Local-Access-Only Subdomains","text":"<p>1. Create a local map file:  - In OPNsense, navigate to: Services --&gt; HAProxy --&gt; Settings --&gt; Advanced --&gt; Map Files. Here, clone the \"PUBLIC_SUBDOMAINS_mapfile,\" rename it to something like \"LOCAL_SUBDOMAINS_mapfile,\" and add all your local-access-only subdomains along with their corresponding backends. Remember that the contents of your \"PUBLIC_SUBDOMAINS_mapfile\" must also be included in the \"LOCAL_SUBDOMAINS_mapfile.\" I will explain the reason for this later.</p> <p>2. Add local conditions and rules:  - Next, go to: Services --&gt; HAProxy --&gt; Settings --&gt; Rules &amp; Checks --&gt; Conditions. Create a condition to detect if the source of the request is a local IP or a FQDN. You can use the predefined \"Source IP is local\" condition, but I prefer to use specific subnets since the predefined condition covers the entire RFC1918 IP range, which is more than I need. As mentioned, you can also check for a FQDN. However, keep in mind that HAProxy resolves these hostnames to their IPs at startup or restart. If the IP of your FQDN changes frequently, this won't work well unless you restart HAProxy regularly, such as every 24 hours using a cron job.  - Next, go to: Services --&gt; HAProxy --&gt; Settings --&gt; Rules &amp; Checks --&gt; Rules. Clone the \"PUBLIC_SUBDOMAINS_rule,\" rename it to something like \"LOCAL_SUBDOMAINS_rule,\" select your \"LOCAL_SUBDOMAINS_SUBNETS_condition,\" and choose your \"LOCAL_SUBDOMAINS_mapfile.\" If you are also using a FQDN condition, like I am, you need to select both your FQDN and subnet conditions with the logical \"or\" operator.    - Finally, go to: Services --&gt; HAProxy --&gt; Settings --&gt; Virtual Services --&gt; Public Services. Place the \"LOCAL_SUBDOMAINS_rule\" before your \"PUBLIC_SUBDOMAINS_rule\" in your \"HTTPS_frontend.\" </p>"},{"location":"cloudflared/traefik/cloudflared-ha-proxy-traefik/#part-8-hide-certificate-on-ip-access","title":"Part 8 - Hide Certificate on IP Access","text":"<p>1. Enable strict SNI:   - Edit \"HTTPS_frontend\" in \"Virtual Services --&gt; Public Services\".   - Change \"curves secp384r1\" to \"curves secp384r1 strict-sni\" in the SSL options.</p>"},{"location":"cloudflared/traefik/cloudflared-ha-proxy-traefik/#part-9-ssllabs-testing","title":"Part 9 - ssllabS testing","text":"<p>We are now going to test our configuration for secureness. 1. Go to https://www.ssllabs.com/ssltest/ 2. Enter your domain to test 3. This will perform deep ssl testing on your domain 4. Wait for the results. You should now have an A+ rating </p>"},{"location":"cloudflared/traefik/cloudflared-ha-proxy-traefik/#part-10-traefik-setup","title":"Part 10 - Traefik setup","text":"<p>Here we are going to use our HAProxy as a reverse proxy in front of Traefik, which then proxies requests to this blog, you'll need to carefully configure each component to work together</p>"},{"location":"cloudflared/traefik/cloudflared-ha-proxy-traefik/#prerequisites","title":"Prerequisites","text":"<p>1. Docker: Ensure Docker is installed and running on your server. 2. Docker Compose: Ensure Docker Compose is installed. 3. HAProxy: Familiarity with HAProxy configuration.</p>"},{"location":"cloudflared/traefik/cloudflared-ha-proxy-traefik/#step-by-step-guide","title":"Step-by-Step Guide","text":"<p>1. Create a Docker Network for traefik and database network to be used by the blog Create a Docker network that all services will use to communicate.</p> <pre><code>  docker network create traefik\n  docker network create db\n</code></pre> <p>2. Deploy traefik using docker compose</p> <pre><code>networks:\n  traefik:\n    external: true\nvolumes:\n  traefik_config:\n    external: true\n  lets_encrypt:\n  traefik_dynamic_config:\n    external: true\nservices:\n  reverse-proxy:\n    # The official v2 Traefik docker image\n    image: traefik:v2.11.2\n    # Enables the web UI and tells Traefik to listen to docker\n    command: --api.insecure=true --metrics.prometheus=true --metrics.prometheus.manualrouting=true\n      - \"--entrypoints.websecure.address=:443\"\n      - \"--entrypoints.web.address=:80\"\n      - \"--log.level=DEBUG\"\n      - \"--configFile=/etc/traefik/traefik.yml\"\n    ports:\n      # The HTTP port\n      - \"80:80\"\n      - \"443:443\"\n      # The Web UI (enabled by --api.insecure=true)\n      - \"8080:8080\"\n      - \"8082:8082\"\n    expose:\n      - 8082\n    restart: unless-stopped\n    volumes:\n      # So that Traefik can listen to the Docker events\n      - /var/run/docker.sock:/var/run/docker.sock\n      - \"traefik_config:/etc/traefik/\"\n      # Mount the dynamic configuration\n      # Mount the cert directory\n      - \"./certs/:/etc/certs/\"\n    networks:\n      - traefik\n    logging:\n      driver: fluentd\n      options:\n        fluentd-address: 127.0.0.1:24224\n        fluentd-async: 'true'\n        tag: docker.traefik\n\n    labels:\n      # Dynamic configuration with Docker Labels\n      # Ref: https://docs.traefik.io/reference/dynamic-configuration/docker/\n      # Explicitly tell Traefik to expose this container\n      - traefik.enable=true\n      # Allow request only from the predefined entry point named \"web\"\n      - traefik.http.routers.traefik-ui.entrypoints=web\n      # The port the dashboard responds on\n      - traefik.http.services.traefik-ui.loadbalancer.server.port=8080\n      # The URL for the traefik ui\n      - traefik.http.routers.traefik-ui.rule=Host(`traefik-docker01.internal`)\n</code></pre> <p>3. Deploy wiki.js</p> <pre><code> services:\n\n  db:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_DB: wiki\n      POSTGRES_PASSWORD: wikijsrocks\n      POSTGRES_USER: wikijs\n    networks:\n      - db\n    logging:\n      driver: \"fluentd\"\n      options:\n        fluentd-address: 127.0.0.1:24224\n        fluentd-async: 'true'\n        tag: docker.postgres_wiki\n    labels:\n      - \"com.centurylinklabs.watchtower.enable=false\"\n    restart: unless-stopped\n    volumes:\n      - db-data:/var/lib/postgresql/data\n\n  wiki:\n    image: ghcr.io/requarks/wiki:2\n    depends_on:\n      - db\n    networks:\n      - traefik\n      - db\n    ports:\n      - \"8084:3000\"\n    environment:\n      ADMIN_EMAIL:\n      ADMIN_PASS: wikiadmin\n      DB_TYPE: postgres\n      DB_PORT: 5432\n      DB_HOST: db\n      DB_USER: wikijs\n      DB_PASS: wikijsrocks\n      DB_NAME: wiki\n    restart: unless-stopped\n    logging:\n      driver: \"fluentd\"\n      options:\n        fluentd-address: 127.0.0.1:24224\n        fluentd-async: 'true'\n        tag: docker.wiki\n\n    labels:\n      # Dynamic configuration with Docker Labels\n      # Ref: https://docs.traefik.io/reference/dynamic-configuration/docker/\n      # Explicitly tell Traefik to expose this container\n      - traefik.enable=true\n      # The domain the service will respond to\n      #- traefik.http.routers.wiki-web.rule=Host(`wiki-docker01.internal`)\n      - traefik.http.routers.wiki-web.rule=Host(`homelab.devopsjourney.wiki`)\n      # Allow request only from the predefined entry point named \"web\"\n      - traefik.http.routers.wiki-web.entrypoints=web\n      # if you have multiple ports exposed on the service, specify port in the web-secure service\n      - traefik.http.services.wiki-web.loadbalancer.server.port=3000\n      - \"com.centurylinklabs.watchtower.enable=false\"\n\n\nvolumes:\n  db-data:\nnetworks:\n  traefik:\n    external: true\n  db:\n    external: true\n</code></pre> <p>Things to note:   - Make sure you set the traefik.http.routers.wiki-web.rule=Host to match your public DNS record in cloudflare</p> <p>4. Go through steps 5 - 9 above to add the service to HAProxy in OPNsense  </p>"},{"location":"cloudflared/traefik/cloudflared-traefik/","title":"cloudflared + traefik + docker for web-hosting without opened ports","text":""},{"location":"cloudflared/traefik/cloudflared-traefik/#introduction","title":"Introduction","text":"<p>This setup could potentially address scenarios such as serving web content from behind a carier grade NAT (CNAT) or in situations where a public IP isn't available. Surprisingly, the solution requires just one additional component: Cloudflare Tunnels. These tunnels establish a link between my server and Cloudflare without necessitating opened ports. In this blog post, I'll delve into my setup for achieving full encryption between the web service and my users, along with key considerations for similar implementations.</p> <p>To read more about cloudflared tunnels view here: https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/</p>"},{"location":"cloudflared/traefik/cloudflared-traefik/#configuration","title":"Configuration","text":""},{"location":"cloudflared/traefik/cloudflared-traefik/#traefik-cloudflared","title":"Traefik + cloudflared","text":"<p>Cloudflare Tunnels are operated via cloudflared, a software daemon provided by Cloudflare that initiates an outbound connection to the nearest Cloudflare points of presence to proxy internet traffic. As Cloudflare Tunnels offer limited routing functionality, specifically path-based routing, we combine them with the widely used reverse proxy Traefik, which integrates seamlessly with Docker. Cloudflare directs traffic to Traefik, which in turn routes it to individual Docker containers housing the web services we aim to expose.</p> <p>Below is the docker-compose.yml configuration for Traefik and cloudflared.</p> <pre><code>networks:\n  cftunnel-transport:\n    external: true\n  cloudflaretunnel:\n    external: true\n\nservices:\n  tunnel:\n    container_name: cloudflared-tunnel-traefik\n    image: cloudflare/cloudflared:2023.10.0-amd64\n    restart: unless-stopped\n    command: tunnel run\n    environment:\n      - \"TUNNEL_TOKEN=\"\n    networks:\n      - cftunnel-transport\n\n  traefik:\n    image: traefik:v2.10.7\n    container_name: traefik_cloudflare_ingress\n    restart: always\n    networks:\n      - cftunnel-transport\n      - cloudflaretunnel\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n      - ./traefik.yml:/traefik.yml:ro\n      - ./certificates.yml:/certificates.yml:ro\n      - ./origin-certificates/:/origin-certificates:ro\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.traefik-ui.rule=Host(`traefik-cf-docker01.internal`)\"\n      - \"traefik.http.services.traefik-ui.loadbalancer.server.port=8085\"\n    logging:\n      driver: fluentd\n      options:\n        fluentd-address: 127.0.0.1:24224\n        fluentd-async: 'true'\n        tag: docker.cloudflareTraefik\n</code></pre> <p>The Compose file defines a container for Traefik and a container for cloudflared. The Docker network cftunnel-transport is used for transport between Traefik and cloudflared. The Docker network cloudflaretunnel is used to expose Docker containers to Traefik.</p> <p>To secure traffic between Traefik and cloudflared, a Cloudflare Origin Certificate is used. This can be generated in the Cloudflare dashboard and the files should be saved as mydomain.tld.pem and mydomain.tld.key into the origin-certificates folder. We will instruct Traefik to secure all TLS traffic with these certificates.</p> <pre><code>tls:\n  stores:\n    default:\n      defaultCertificate:\n        certFile: /origin-certificates/rorymac.com.pem\n        keyFile: /origin-certificates/rorymac.com.key\n\n  certificates:\n    - certFile: /origin-certificates/rorymac.com.pem\n      keyFile: /origin-certificates/rorymac.com.key\n</code></pre> <p>traefik.yaml file:</p> <pre><code>log:\n  level: DEBUG\n\nentryPoints:\n  websecure:\n    address: \":443\"\n\nproviders:\n  docker:\n    endpoint: \"unix:///var/run/docker.sock\"\n    exposedByDefault: false\n  file:\n    filename: certificates.yaml\n</code></pre>"},{"location":"cloudflared/traefik/cloudflared-traefik/#cloudflare-setup","title":"Cloudflare setup","text":"<p>Login to the cloudflare portal and head over to Zero Trust &gt; Networks &gt; Tunnels</p> <p>Add a new tunnel and configure the following:  Add a public host name and configure the following:  </p> <p>To configure a service in the Cloudflare tunnel, add simply https://traefik as the destination. For Traefik to know which service to route the request to, we also have to specify the origin server name. Since Traefik can also speak HTTP/2, we can enable that as well. Also enable No TLS Verify</p>"},{"location":"cloudflared/traefik/cloudflared-traefik/#adding-a-service-to-the-cloudflared-traefik-tunnel","title":"Adding a service to the cloudflared / traefik tunnel","text":"<pre><code>services:\n\n  vaultwarden:\n    container_name: vaultwarden\n    hostname: vaultwarden\n    image: vaultwarden/server:1.30.1\n    restart: unless-stopped\n    networks:\n       cloudflaretunnel:\n    expose:\n      - 80                 # Web UI\n      - 443                # Web UI\n    env_file:\n      - container-vars.env\n    volumes:\n      - /etc/localtime:/etc/localtime:ro\n      - ./data:/data\n    labels:\n      - traefik.enable=true\n      - traefik.http.routers.vaultwarden.rule=Host(`vaultwarden.rorymac.com`)\n      - traefik.http.routers.vaultwarden.entrypoints=websecure\n      - traefik.http.routers.vaultwarden.tls=true\n      - traefik.http.routers.vaultwarden.service=vaultwarden\n      - traefik.http.services.vaultwarden.loadbalancer.server.port=80\nnetworks:\n  cloudflaretunnel:\n    external: true\n</code></pre>"},{"location":"docker/dev_container/","title":"\ud83d\udc33 Homelab DCC Container","text":"<p>This repository provides detailed instructions on building and deploying the DCC dev container.</p>"},{"location":"docker/dev_container/#table-of-contents","title":"\ud83d\udcc4 Table of Contents","text":"<ul> <li>\ud83d\udd28 GitLab CI/CD Build</li> <li>\ud83d\udcda How to deploy the DEV Container</li> </ul>"},{"location":"docker/dev_container/#contact","title":"\ud83d\udceb Contact","text":""},{"location":"docker/dev_container/BUILD/","title":"\ud83d\udd28 Docker-Compose Build","text":"<p>This guide will walk you through the steps to build the dev-container image.</p>"},{"location":"docker/dev_container/BUILD/#build-steps","title":"\ud83d\ude80 Build Steps","text":""},{"location":"docker/dev_container/BUILD/#prerequisites","title":"Prerequisites","text":"<p>Make sure the ca.crt (homelab root certificate) and the python pip requirements.txt file are in the same director as the Dockerfile</p> <ol> <li> <p>Go to your home directory</p> <pre><code>cd $HOME\n</code></pre> </li> <li> <p>git clone https://gitlab-docker01.internal/homelab/containers/dev.git</p> </li> <li> <p>Go to the cloned folder.</p> <pre><code>cd $HOME/dev\n</code></pre> </li> <li> <p>Update the Docker file</p> </li> <li> <p>Update Image and Tag and software version tags in the gitlab-ci.yml file</p> </li> <li> <p>Push code to a feature branch and check the hadolint analyze stage</p> </li> <li> <p>Create a git tag so the build phase begins</p> </li> <li> <p>Wait for the build phase to complete and merge the feature branch to the main branch, this will then create a gitlab release</p> </li> </ol>"},{"location":"docker/dev_container/BUILD/#contact","title":"\ud83d\udceb Contact","text":""},{"location":"docker/dev_container/DEPLOY/","title":"\ud83d\udcda How to deploy the DEV Container","text":"<p>This guide will walk you through how to deploy a docker development container.</p>"},{"location":"docker/dev_container/DEPLOY/#deployment-steps","title":"\ud83d\ude80 Deployment Steps","text":"<ol> <li> <p>Run: docker login registry-gitlab-docker01.internal         docker pull registry-gitlab-docker01.internal/homelab/containers/dev:latest</p> </li> <li> <p>Go to your home directory</p> <pre><code>cd $HOME\n</code></pre> </li> <li> <p>git clone https://gitlab-docker01.internal/homelab/containers/dev.git</p> </li> <li> <p>Go to the cloned folder.</p> <pre><code>cd $HOME/dev\n</code></pre> </li> <li> <p>Copy the sample env.example file:</p> <pre><code>cp -R .env.example .env.user\n</code></pre> </li> <li> <p>Update the following environment variables in the .env.user file</p> </li> <li>IMAGE_NAME</li> <li>IMAGE_TAG</li> <li> <p>USER</p> </li> <li> <p>Copy your host .gitconfig to /home/{TGI}/container_config/</p> <pre><code>cp $HOME/.gitconfig $HOME/container_config/\n</code></pre> </li> <li> <p>Copy your host .bashrc to /home/{TGI}/container_config/</p> <pre><code>cp $HOME/.bashrc $HOME/container_config/\n</code></pre> </li> <li> <p>To deploy your dev container run:</p> <pre><code>docker-compose --env-file .env.user up -d\n</code></pre> </li> <li> <p>To use your dev container run:</p> <pre><code>docker exec -it {TGI}_devcontainer /bin/bash\n</code></pre> </li> <li> <p>Your host working directory structure should look like the following example:</p> <pre><code>.\n\u251c\u2500\u2500 home\n\u2502   \u251c\u2500\u2500 {USER}\n\u2502   \u2502   \u251c\u2500\u2500 container_config\n\u2502   \u2502   \u2502   |\n\u2502   \u2502   \u2502   |\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 .bashrc\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 .gitconfig\n\u2502   \u2502   \u2514\u2500\u2500 dev-container\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2502   \u2514\u2500\u2500 git\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 {PROJECT-A}\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 {PROJECT-B}\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ...\n</code></pre> </li> <li> <p>To stop your dev container run:</p> <pre><code>docker-compose --env-file .env.user down\n</code></pre> </li> </ol>"},{"location":"docker/dev_container/DEPLOY/#contact","title":"\ud83d\udceb Contact","text":""},{"location":"kubernetes/kubespray/upgrade-process/","title":"Upgrade process","text":"<ol> <li>git switch -c release-2.26</li> <li>git fetch upstream release-2.26</li> <li>git pull upstream release-2.26 --force</li> <li>git merge upstream/release-2.26</li> <li>change k8s version in vars and run:    git commit -m \"updating cluster to kubespray release 2.26\"</li> </ol>"}]}